Рекомендации по выбору библиотек {-}
--------------------------------

При реализации некоторых частей практических заданий может потребоваться
использование сторонних библиотек — например, для графических интерфейсов,
клиент-серверной архитектуры, работы с базой данных, генерации кода и пр.

Для установки библиотек рекомендуется пользоваться менеджером пакетов [`Cabal`](https://www.haskell.org/cabal/).
Например, для установки пакета `gloss` достаточно выполнить команду `cabal install gloss`.

### Синтаксический разбор {-}

Для синтаксического разбора рекомендуется использовать комбинаторные библиотеки —
например, [`parsec`](https://hackage.haskell.org/package/parsec) или [`attoparsec`](https://hackage.haskell.org/package/attoparsec).
Parsec предоставляет более выразительные средства и лучше подходит для разбора исходного кода и конфигурационных файлов.
`attoparsec` предлагает более простой интерфейс и меньше возможностей, но на несколько порядков лучше по производительности
и подходит для разбора сетевых протоколов, логов, бинарных данных.

### Генерация кода {-}

Для генерации объектного кода проще всего использовать существующий низкоуровневый
язык программирования, из которого уже можно легко получить объектный код. К таким языкам
относятся C, [C$--$](https://ru.wikipedia.org/wiki/C--) и язык [LLVM](https://ru.wikipedia.org/wiki/Low_Level_Virtual_Machine).
Последний часто используется в компиляторах, поскольку специально создан для этой цели.

Генерация кода для LLVM на Haskell реализуется при помощи библиотеки
[`llvm-general`](https://hackage.haskell.org/package/llvm-general).

### Графический интерфейс {-}

Библиотека [`gloss`](https://hackage.haskell.org/package/gloss) предоставляет простой и удобный интерфейс для работы с векторной 2D графикой.
Для игр рекомендуется использование модулей `Graphics.Gloss.Interface.Pure.Game` или `Graphics.Gloss.Interface.IO.Game`.
Для моделирования можно использовать модули `Graphics.Gloss.Interface.Pure.Simulate` или `Graphics.Gloss.Interface.IO.Simulate`.

### Клиент-серверная архитектура {-}

Для большинства практических заданий в качестве протокола общения между клиентом и сервером
можно использовать [HTTP](https://ru.wikipedia.org/wiki/HTTP). Это возможно, если сервер не передаёт сообщения клиенту без запроса от последнего.
Например, пошаговые игры вполне могут быть реализованы таким образом. При реализации HTTP сервера рекомендуется
использовать [архитектуру REST](https://ru.wikipedia.org/wiki/REST).

Существует множество web-фреймворков для реализации серверной части, но для практических заданий
достаточно будет использовать самые простые из них:
[`scotty`](http://hackage.haskell.org/package/scotty) или [`servant`](http://haskell-servant.github.io).
Последний позволяет автоматически генерировать код для клиентской части, но использует более продвинутые
возможности Haskell.
Для клиентской части предлагается использовать библиотеку [`wreq`](http://www.serpentine.com/wreq/).

Для более тесной связи клиента и сервера можно использовать [протокол TCP](https://ru.wikipedia.org/wiki/TCP).
Соответствующая библиотека — [`network-simple`](https://hackage.haskell.org/package/network-simple).

Для передачи данных по сети рекомендуется использовать сериализацию/десериализацию данных. В случае HTTP
предлагается использовать формат JSON (используя библиотеку [`aeson`](https://hackage.haskell.org/package/aeson)).
В случае TCP — бинарное представление (используя библиотеку [`binary`](https://hackage.haskell.org/package/binary)).

### Многопоточность {-}

Серверные приложения используют многопоточность, чтобы взаимодействовать одновременно с множеством клиентов.
Приложения с графическим интерфейсом используют многопоточность, чтобы избежать эффекта замирания во
время потенциально длительных расчётов (например, в реализации ИИ) или сетевого взаимодействия.

Для использования общей памяти между потоками одного приложения в Haskell используется
[программная транзакционная память](https://ru.wikipedia.org/wiki/Программная_транзакционная_память).
Соответствующая библиотека [`stm`](https://hackage.haskell.org/package/stm) входит в список стандартных пакетов.
В практических заданиях достаточно использования [`TVar`](https://hackage.haskell.org/package/stm/docs/Control-Concurrent-STM-TVar.html)
и, возможно, [`TChan`](https://hackage.haskell.org/package/stm/docs/Control-Concurrent-STM-TChan.html).

### База данных {-}

Для работы с базой данных рекомендуется использовать библиотеку [`persistent`](https://hackage.haskell.org/package/persistent).
Эта библиотека предоставляет интерфейс, не зависящий от конкретной используемой СУБД и поддерживает
как минимум PostgreSQL, SQLite, MySQL and MongoDB. Для сложных запросов (например, по нескольким таблицам)
предлагается использовать библиотеку [`esqueleto`](https://hackage.haskell.org/package/esqueleto), которая работает поверх `persistent`.

