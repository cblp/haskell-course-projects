=====================
Методические указания
=====================

Групповая работа
================

Цель практического задания — разработка законченного приложения
или программной библиотеки на языке программирования Haskell.

Каждое задание может быть выполнено как в одиночку, так и группой в несколько человек
(максимальное количество человек в группе зависит от задания).

В каждом задании выделена базовая часть.
Все участники должны разбираться в реализации базовой части и быть в состоянии воспроизвести её.

Помимо базовой части в задании присутствует несколько дополнительных частей, по одной на каждого участника.
Таким образом, если задание выполняется в одиночку, студент должен реализовать базовую и хотя бы одну дополнительную часть.

Для эффективной работы (в том числе в одиночку) предлагается:

- обсуждать структуру проекта и каждой части до реализации (работать вместе проще, когда вы работаете в одном направлении);
- разбивать реализацию на логические модули (например, дополнительные части заданий должны находиться в разных модулях и минимально зависеть друг от друга);
- пользоваться системой контроля версий (например, Git);
- придерживаться правил оформления исходного кода (хорошо написанный код легко читать, проверять и модифицировать);
- проводить просмотр кода (code review) других участников проекта (это позволяет улучшить общее представление о проекте, уменьшает шанс логических и других ошибок в общем проекте, позволяет поддерживать исходный код оформленным).

Правила оформления исходного кода
=================================

Программирование — это в равной мере искусство и ремесло.
И, как известно любому художнику, ограничения расширяют, а не подавляют творческие способности.

Правила оформления исходного кода:

- используйте `camelCase`_ для именования функций и переменных;
- используйте описательные названия функций, пусть они будут настолько
  длинные, насколько необходимо, но не длинее этого.
  Хорошо: ``solveRemaining``. Плохо: ``slv``. Ужасно: ``solveAllTheCasesWhichWeHaven'tYetProcessed``.
- **не** используйте символы табуляции: Haskell чувствителен к отступам
  и табуляция может сильно испортить вам жизнь. Заметьте, что это не
  значит, что вам придётся нажимать пробел миллион раз: ваш любимый текстовый редактор
  умеет заменять табуляцию на пробелы автоматически.
- старайтесь не писать строчки длинее 80 символов. Код, который не приходится
  пролистывать по горизонтали читать обычно удобнее.
- описывайте тип для каждой функции на верхнем уровне. Сигнатура типа значительно
  улучшает документацию и способствует правильному мышлению. Также явное указание
  типов способствует лучшим сообщениям об ошибках при компиляции.
  Локально определенные функции и константы (определенные при помощи ``let`` и ``where``)
  не нуждаются в сигнатурах, но их выписывание не навредит (это также улучшает
  сообщения об ошибках).
- формулируйте развёрнутый комментарий для каждой функции на верхнем уровне.
- используйте флаг ``-Wall`` при компиляции или напишите ``{-# OPTIONS_GHC -Wall #-}``
  на самом начале файла с кодом. Этот флаг включает все предупредительные сообщения
  компилятора.
- по возможности разбивайте ваш код на простые функции (каждая с одним ясным
  предназначением) и составляйте из них программу;
- пишите всюду определённые функции: они не должны завершаться аварийно
  ни на одном возможном входе.

.. _camelCase: https://ru.wikipedia.org/wiki/CamelCase

Рекомендации по оформлению задания
==================================

Каждое практическое задание можно реализовать множеством способов с различными наборами возможностей.
Для того, чтобы другим людям (в том числе соучастникам и преподавателям) было проще разобраться в законченном проекте,
рекомендуется:

- добавить файл ``README``:
    - с описанием проекта;
    - инструкциями по установке и запуску;
    - описанием реализованных возможностей;
- оформить проект в виде пакета Cabal_:
    - для создания пакета должно быть достаточно выполнить команду ``cabal init``;
    - для работы с пакетами Cabal рекомендуется использовать песочницы (`Cabal sandboxes`_);
    - установка пакета осуществляется командой ``cabal install`` из директории проекта;
    - тестирование пакета осуществляется командой ``cabal test``;
- если вы храните основную версию репозитория на GitHub_, вы можете использовать `Travis CI`_
  для автоматической сборки и тестирования вашего проекта.

.. _Cabal:            https://www.haskell.org/cabal/
.. _Cabal sandboxes:  http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
.. _GitHub:           https://github.com
.. _Travis CI:        http://docs.travis-ci.com

Рекомендации по выбору библиотек
================================

При реализации некоторых частей практических заданий может потребоваться
использование сторонних библиотек — например, для графических интерфейсов,
клиент-серверной архитектуры, работы с базой данных, генерации кода и пр.

Для установки библиотек рекомендуется пользоваться менеджером пакетов Cabal_.
Например, для установки пакета ``gloss`` достаточно выполнить команду ``cabal install gloss``.

Синтаксический разбор
---------------------

Для синтаксического разбора рекомендуется использовать комбинаторные библиотеки —
например, `parsec <https://hackage.haskell.org/package/parsec>`_ или `attoparsec <https://hackage.haskell.org/package/attoparsec>`_.
Parsec предоставляет более выразительные средства и лучше подходит для разбора исходного кода и конфигурационных файлов.
``attoparsec`` предлагает более простой интерфейс и меньше возможностей, но на несколько порядков лучше по производительности
и подходит для разбора сетевых протоколов, логов, бинарных данных.

Генерация кода
--------------

Для генерации объектного кода проще всего использовать существующий низкоуровневый
язык программирования, из которого уже можно легко получить объектный код. К таким языкам
относятся C, `C-- <https://ru.wikipedia.org/wiki/C-->`_ и язык `LLVM <https://ru.wikipedia.org/wiki/Low_Level_Virtual_Machine>`_.
Последний часто используется в компиляторах, поскольку специально создан для этой цели.

Генерация кода для LLVM на Haskell реализуется при помощи библиотеки
`llvm-general <https://hackage.haskell.org/package/llvm-general>`_.

Графический интерфейс
---------------------

Библиотека `gloss <https://hackage.haskell.org/package/gloss>`_ предоставляет простой и удобный интерфейс для работы с векторной 2D графикой.
Для игр рекомендуется использование модулей ``Graphics.Gloss.Interface.Pure.Game`` или ``Graphics.Gloss.Interface.IO.Game``.
Для моделирования можно использовать модули ``Graphics.Gloss.Interface.Pure.Simulate`` или ``Graphics.Gloss.Interface.IO.Simulate``.

Клиент-серверная архитектура
----------------------------

Для большинства практических заданий в качестве протокола общения между клиентом и сервером
можно использовать `HTTP <https://ru.wikipedia.org/wiki/HTTP>`_. Это возможно, если сервер не передаёт сообщения клиенту без запроса от последнего.
Например, пошаговые игры вполне могут быть реализованы таким образом. При реализации HTTP сервера рекомендуется
использовать `архитектуру REST <https://ru.wikipedia.org/wiki/REST>`_.

Существует множество web-фреймворков для реализации серверной части, но для практических заданий
достаточно будет использовать самые простые из них:
`scotty <http://hackage.haskell.org/package/scotty>`_ или `servant <http://haskell-servant.github.io>`_.
Последний позволяет автоматически генерировать код для клиентской части, но использует более продвинутые
возможности Haskell.
Для клиентской части предлагается использовать библиотеку `wreq <http://www.serpentine.com/wreq/>`_.

Для более тесной связи клиента и сервера можно использовать `протокол TCP <https://ru.wikipedia.org/wiki/TCP>`_.
Соответствующая библиотека — `network-simple <https://hackage.haskell.org/package/network-simple>`_.

Для передачи данных по сети рекомендуется использовать сериализацию/десериализацию данных. В случае HTTP
предлагается использовать формат JSON (используя библиотеку `aeson <https://hackage.haskell.org/package/aeson>`_).
В случае TCP — бинарное представление (используя библиотеку `binary <https://hackage.haskell.org/package/binary>`_).

Многопоточность
---------------

Серверные приложения используют многопоточность, чтобы взаимодействовать одновременно с множеством клиентов.
Приложения с графическим интерфейсом используют многопоточность, чтобы избежать эффекта замирания во
время потенциально длительных расчётов (например, в реализации ИИ) или сетевого взаимодействия.

Для использования общей памяти между потоками одного приложения в Haskell используется
`программная транзакционная память <https://ru.wikipedia.org/wiki/Программная_транзакционная_память>`_.
Соответствующая библиотека `stm <https://hackage.haskell.org/package/stm>`_ входит в список стандартных пакетов.
В практических заданиях достаточно использования `TVar <https://hackage.haskell.org/package/stm/docs/Control-Concurrent-STM-TVar.html>`_
и, возможно, `TChan <https://hackage.haskell.org/package/stm/docs/Control-Concurrent-STM-TChan.html>`_.

База данных
-----------

Для работы с базой данных рекомендуется использовать библиотеку `persistent <https://hackage.haskell.org/package/persistent>`_.
Эта библиотека предоставляет интерфейс, не зависящий от конкретной используемой СУБД и поддерживает
как минимум PostgreSQL, SQLite, MySQL and MongoDB. Для сложных запросов (например, по нескольким таблицам)
предлагается использовать библиотеку `esqueleto <https://hackage.haskell.org/package/esqueleto>`_, которая работает поверх `persistent`.

