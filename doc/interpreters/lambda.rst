=================
Лямбда-исчисление
=================

Описание
--------

:math:`\lambda`-исчисление (лямбда-исчисление) лежит в основе большинства функциональных языков программирования:
семейства Лиспа (Common Lisp, Scheme, Clojure и др.) и семейства ML (Standard ML, Haskell, Agda и пр.).

:math:`\lambda`-исчисление состоит из языка :math:`\lambda`-выражений и набора правил преобразования.
Базовые правила построения :math:`\lambda`-выражений:

- переменная :math:`x` является :math:`\lambda`-выражением;
- если :math:`e` — :math:`\lambda`-выражение, а :math:`x` — переменная, то :math:`(\lambda x.\; e)` также :math:`\lambda`-выражение (**лямбда-абстракция**);
- если :math:`e_1` и :math:`e_2` — :math:`\lambda`-выражения, то :math:`(e_1\;e_2)` также :math:`\lambda`-выражение (**аппликация**).

Для удобства работы с :math:`\lambda`-выражениями, при записи могут использоваться следующие упрощения:

внешние скобки могут быть опущены
  :math:`(\lambda x.\; e_1)\;e_2`;

аппликация считается лево-ассоциативной
  :math:`e_1\;e_2\;e_3 \equiv ((e_1\;e_2)\;e_3)`;

тело :math:`\lambda`-выражения распространяется вправо насколько возможно
  :math:`\lambda x.\; e_1\;e_2 \equiv \lambda x.\; (e_1\;e_2)`;

последовательные :math:`\lambda`-абстракции схлопываются в одну
  :math:`\lambda x.\; \lambda y.\; \lambda z.\; e \equiv \lambda x\;y\;z.\; e`.

Оператор :math:`\lambda` *связывает* переменную в выражении :math:`\lambda x.\;e`. Переменные, подпадающие под какой-либо
оператор :math:`\lambda`-абстракции, называются *связанными*. Все прочие переменные называются *свободными*.
Например, переменная :math:`y` свободна в выражении :math:`\lambda x.\;y\;x`. Переменная связывается *ближайшим* оператором :math:`\lambda`.
Например, единственное вхождение переменной :math:`x` в выражении :math:`\lambda x.\;y\;(\lambda x.\;x)` связано со вторым оператором
:math:`\lambda`.

Значение :math:`\lambda`-выражения определяется правилами редукции:

:math:`\alpha`-**конверсия**
  переименовывание связанных переменных

:math:`\beta`-**редукция**
  применение функции к аргументам

:math:`\eta`-**конверсия**
  выражает принцип *две функции идентичны, если имеют одинаковый результат на всех входах*

Применение функции к аргументам осуществляется засчёт подстановки выражения-аргумента
вместо связанной переменной в теле :math:`\lambda`-выражения:

.. math::
   :nowrap:

   \begin{aligned}
     x[x \mapsto e] & \equiv e \\
     y[x \mapsto e] & \equiv y, \text{если $y \neq x$} \\
     (e_1\;e_2) [x \mapsto e] & \equiv (e_1 [x \mapsto e])\;(e_2 [x \mapsto e]) \\
     (\lambda x.\;e_1) [x \mapsto e] & \equiv \lambda x.\;e_1 \\
     (\lambda y.\;e_1) [x \mapsto e] & \equiv \lambda y.\;(e_1 [x \mapsto e]), \text{если $y \neq x$ и $y$ не входит свободно в $e$}
   \end{aligned}

Язык :math:`\lambda`-выражений может быть расширен:

- базовыми типами данных (например, числа, булевы значения, строки);
- базовыми контейнерными типами (списки и кортежи);
- встроенными операциями (например, :math:`+`, :math:`-`, :math:`\sin`, :math:`\cos`, :math:`and`, :math:`or`, :math:`++`)
- специальными конструкциями (например, :math:`if \ldots then \ldots else \ldots` или :math:`let \ldots = \ldots in \ldots`);
- системой типов;
- пользовательские структуры данных;
- и т.д.

Минимальные требования (базовая часть)
--------------------------------------

Базовая реализация проекта, в которой должны разбираться все участники, должна:

- определять структуру данных для синтаксического дерева;
- содержать раздельно парсер и интерпретатор (с любой стратегией редукций);
- предоставлять простую интерактивную среду программирования (REPL).

Расширенный парсер (дополнительная часть)
-----------------------------------------

Расширенный парсер должен добавлять хотя бы 2 различные возможности к базовому варианту.
Ниже перечислены возможные варианты расширения парсера, однако этим списком они не ограничены:

- разбор расширенного :math:`\lambda`-исчисления;
- восстановление после ошибок (например, если пользователь написал запятую (``,``) вместо точки (``.``),
  парсер может запомнить эту ошибку и продолжить разбор программы);
- поддержка пользовательских инфиксных операций с возможностью задать приоритет и ассоциативность;
- и т.д.

Система типов (дополнительная часть)
------------------------------------

Система типов помогает определить семантику :math:`\lambda`-выражений, но также может быть использована
для оптимизаций при интерпретации и генерации кода.

Система типов должна поддерживать хотя бы 2 различные возможности:

- базовые типы (числа, булев тип, строки);
- контейнерные типы (списки, кортежи, суммы);
- параметрический полиморфизм;
- пользовательские типы данных;
- механизм автоматического вывода типа для терма;
- и т.д.

Расширенная интерактивная среда (дополнительная часть)
------------------------------------------------------

Расширенная интерактивная среда должна добавлять хотя бы 2 различные возможности к базовому интерфейсу.
Ниже перечислены возможные варианты расширения интерактивной среды, однако этим списком они не ограничены:

- команды интерпретатора:
  - показать все возможные варианты редукции терма (одного шага) и выбрать один;
  - показать тип выражения;
  - поменять порядок редукции;
  - перевести терм из/в кодировку Чёрча;
  - загрузить программу из файла;
- интерпретация расширенного :math:`\lambda`-исчисления;
- дружелюбные сообщения об ошибках (например, для замкнутых термов при опечатке в имени переменной
  можно предложить имена переменных, отличающихся одной буквой, которые находятся в области видимости);
- и т.д.

Генерация кода (дополнительная часть)
-------------------------------------

Модуль генерации кода — предпоследний этап компиляции.
Генерация кода может быть реализована многими способами, но чтобы простым
образом получить портируемый компилятор, можно генерировать промежуточный код
на низкоуровневом языке программирования, таком как C или еще ниже, например, LLVM.

Генерация кода должна переводить именованные :math:`\lambda`-термы в соответствующие функции
(для этого язык должен быть расширен возможностью именования :math:`\lambda`-термов).

Демонстрация генерации кода должна включать в себя программу на любом языке,
использующую сгененированный объектный код при сборке.

